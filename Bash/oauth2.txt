#!/bin/bash
# ================================================
# SWIFT JWT Bearer token request using .p12 + bash + openssl + curl
# Works on any modern Linux (Ubuntu, RHEL, etc.)
# ================================================

# --- YOUR CONFIGURATION (replace these) ---
P12_FILE="your-certificate.p12"          # Path to your .p12 file
P12_PASSWORD="your_p12_password"         # Password for the .p12 (leave empty if none: "")
CONSUMER_KEY="your_consumer_key_here"
CONSUMER_SECRET="your_consumer_secret_here"
SCOPE="your.required.scope.here"         # e.g. payment.initiation.v5
ENV="sandbox"                            # or "production"

# Token endpoint
if [ "$ENV" = "production" ]; then
    TOKEN_ENDPOINT="https://api.swift.com/oauth2/v1/token"
else
    TOKEN_ENDPOINT="https://sandbox.swift.com/oauth2/v1/token"
fi

# --- 1. Extract private key and certificate from .p12 in memory ---
# Private key (PEM format, no password prompt after this)
PRIVATE_KEY=$(openssl pkcs12 -in "$P12_FILE" -nocerts -nodes -passin pass:"$P12_PASSWORD" 2>/dev/null)

# X.509 certificate in base64 (without BEGIN/END lines) for x5c header
X5C=$(openssl pkcs12 -in "$P12_FILE" -clcerts -nokeys -passin pass:"$P12_PASSWORD" 2>/dev/null | \
      openssl x509 -outform DER | base64 -w 0)

# --- 2. JWT claims and headers ---
ISS="$CONSUMER_KEY"
SUB=$(openssl pkcs12 -in "$P12_FILE" -nokeys -passin pass:"$P12_PASSWORD" 2>/dev/null | \
      openssl x509 -noout -subject | sed 's/^subject=//')   # Exact subject DN
AUD="$TOKEN_ENDPOINT"
JTI=$(openssl rand -hex 16)
IAT=$(date +%s)
EXP=$((IAT + 300))   # 5 minutes validity

# JWT Header (RS256 + x5c chain - SWIFT requires the signing cert in x5c)
HEADER_RAW='{"alg":"RS256","typ":"JWT","x5c":["'"$X5C"'"]}'
HEADER=$(echo -n "$HEADER_RAW" | base64 -w 0 | tr '/+' '_-' | tr -d '=')

# JWT Payload
PAYLOAD_RAW='{"iss":"'"$ISS"'","sub":"'"$SUB"'","aud":"'"$AUD"'","jti":"'"$JTI"'","iat":'"$IAT"',"exp":'"$EXP"'}'
PAYLOAD=$(echo -n "$PAYLOAD_RAW" | base64 -w 0 | tr '/+' '_-' | tr -d '=')

# --- 3. Sign the JWT (RS256) ---
SIGNING_INPUT="$HEADER.$PAYLOAD"

SIGNATURE=$(echo -n "$SIGNING_INPUT" | \
            openssl dgst -sha256 -sign <(echo "$PRIVATE_KEY") | \
            base64 -w 0 | tr '/+' '_-' | tr -d '=')

JWT="$HEADER.$PAYLOAD.$SIGNATURE"

# --- 4. Basic Auth for client authentication ---
BASIC_AUTH=$(echo -n "${CONSUMER_KEY}:${CONSUMER_SECRET}" | base64 -w 0)

# --- 5. Request access_token ---
echo "Requesting token from $TOKEN_ENDPOINT ..."
echo "JWT (first 100 chars): ${JWT:0:100}..."

curl -s -X POST "$TOKEN_ENDPOINT" \
  -H "Authorization: Basic $BASIC_AUTH" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer" \
  -d "assertion=$JWT" \
  -d "scope=$SCOPE" | jq .

# If jq is not installed, remove "| jq ." for raw JSON output

Save as swift_jwt_token.sh
Make executable: chmod +x swift_jwt_token.sh
Edit the configuration section at the top with your actual values
Run: ./swift_jwt_token.sh

curl -H "Authorization: Bearer xisS2RfQ9A9GQ5BKv8dFuwelM15r" https://sandbox.swift.com/some-api-endpoint



#!/bin/bash
set -euo pipefail

# ==================== CONFIGURATION ====================
P12_FILE="your-certificate.p12"              # ← CHANGE THIS
P12_PASSWORD="your_p12_password"             # ← CHANGE THIS (or "" if none)
CONSUMER_KEY="your_consumer_key"             # ← CHANGE THIS
CONSUMER_SECRET="your_consumer_secret"       # ← CHANGE THIS
SCOPE="payment.initiation.v5"                 # ← CHANGE THIS (example)
ENV="sandbox"                                 # ← "sandbox" or "production"
# =======================================================

# Token endpoint + mutual TLS handling
if [ "$ENV" = "production" ]; then
    TOKEN_ENDPOINT="https://api.swift.com/oauth2/v1/token"
    CERT_OPTS="--cert-type P12 --cert $P12_FILE:$P12_PASSWORD --pass $P12_PASSWORD"
else
    TOKEN_ENDPOINT="https://sandbox.swift.com/oauth2/v1/token"
    CERT_OPTS=""
fi

echo "=== SWIFT JWT Bearer Token Request ==="
echo "Environment : $ENV"
echo "Endpoint    : $TOKEN_ENDPOINT"
echo "Scope       : $SCOPE"
echo

# ============ Safety checks ============
echo "Checking .p12 file..."
[ -f "$P12_FILE" ] || { echo "ERROR: $P12_FILE not found"; exit 1; }
[ -r "$P12_FILE" ] || { echo "ERROR: $P12_FILE not readable"; exit 1; }

if ! openssl pkcs12 -in "$P12_FILE" -passin pass:"$P12_PASSWORD" -nokeys >/dev/null 2>&1; then
    echo "ERROR: Wrong password or corrupted .p12 file"
    exit 1
fi
echo ".p12 file is readable and password is correct"
echo

# ============ Extract private key (in memory) ============
PRIVATE_KEY=$(openssl pkcs12 -in "$P12_FILE" -nocerts -nodes -passin pass:"$P12_PASSWORD" 2>/dev/null)

# ============ Extract ONLY the leaf certificate for x5c (critical!) ============
LEAF_PEM=$(openssl pkcs12 -in "$P12_FILE" -clcerts -nokeys -passin pass:"$P12_PASSWORD" 2>/dev/null | openssl x509)
X5C=$(echo "$LEAF_PEM" | sed -n '/-----BEGIN CERTIFICATE-----/d; /-----END CERTIFICATE-----/d; p' | tr -d '\r\n ')

# 2. subject – Postman-exact version
SUBJECT=$(openssl pkcs12 -in "$P12_FILE" -clcerts -nokeys -passin pass:"$P12_PASSWORD" 2>/dev/null | \
          openssl x509 -noout -subject -nameopt RFC2253,sep_comma_plus,utf8 | \
          sed 's/^subject=//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | tr '+' ',' )

echo "Using subject DN as 'sub': $SUBJECT"
echo "x5c length: ${#X5C} chars (should be ~1700–1900)"
echo

# ============ Build JWT ============
ISS="$CONSUMER_KEY"
AUD="$TOKEN_ENDPOINT"
JTI=$(openssl rand -hex 16)
IAT=$(date +%s)
EXP=$((IAT + 300))  # 5 minutes

HEADER_RAW="{\"alg\":\"RS256\",\"typ\":\"JWT\",\"x5c\":[\"$X5C\"]}"
PAYLOAD_RAW="{\"iss\":\"$ISS\",\"sub\":\"$SUBJECT\",\"aud\":\"$AUD\",\"jti\":\"$JTI\",\"iat\":$IAT,\"exp\":$EXP}"

HEADER=$(echo -n "$HEADER_RAW"   | base64 -w 0 | tr '/+' '_-' | tr -d '=')
PAYLOAD=$(echo -n "$PAYLOAD_RAW" | base64 -w 0 | tr '/+' '_-' | tr -d '=')
SIGNING_INPUT="$HEADER.$PAYLOAD"

SIGNATURE=$(echo -n "$SIGNING_INPUT" | \
            openssl dgst -sha256 -sign <(echo "$PRIVATE_KEY") | \
            base64 -w 0 | tr '/+' '_-' | tr -d '=') || \
            { echo "ERROR: Signing failed"; exit 1; }

JWT="$HEADER.$PAYLOAD.$SIGNATURE"

echo "JWT created (first 120 chars): ${JWT:0:120}..."
echo

# ============ Basic Auth ============
BASIC_AUTH=$(echo -n "$CONSUMER_KEY:$CONSUMER_SECRET" | base64 -w 0)

# ============ Final request (very verbose) ============
echo "=== Sending request (with mutual TLS: $CERT_OPTS) ==="
echo

curl -v --fail-with-body $CERT_OPTS \
  -X POST "$TOKEN_ENDPOINT" \
  -H "Authorization: Basic $BASIC_AUTH" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  --data-urlencode "grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer" \
  --data-urlencode "assertion=$JWT" \
  --data-urlencode "scope=$SCOPE"

echo
echo "=== Done ==="
echo "If you see JSON with access_token → SUCCESS!"
echo "If you see an error → copy-paste it here and I'll fix it in 10 seconds."