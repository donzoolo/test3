Yes, you can achieve similar logging in JUnit 5 (JUnit Jupiter) by using TestWatcher as an extension. JUnit 5 provides a more flexible extension model that can be used to accomplish this task.

Here's how you can do it:

Step-by-Step Implementation
Create a Custom TestWatcher Extension: Create a class that implements TestWatcher and uses SLF4J for logging.
Register the Extension in the Base Test Class: Use the @ExtendWith annotation in the base test class to apply the custom extension to all test classes that extend the base class.
Step 1: Create a Custom TestWatcher Extension
Create a custom extension that implements TestWatcher and logs messages before and after each test method.

java
Skopiuj kod
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.extension.TestWatcher;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;

public class LoggingTestWatcherExtension implements TestWatcher {
    private static final Logger logger = LoggerFactory.getLogger(LoggingTestWatcherExtension.class);
    private static final AtomicInteger testCounter = new AtomicInteger(0);

    @Override
    public void testSuccessful(ExtensionContext context) {
        logTestFinish(context, "successful");
    }

    @Override
    public void testFailed(ExtensionContext context, Throwable cause) {
        logTestFinish(context, "failed");
    }

    @Override
    public void testAborted(ExtensionContext context, Throwable cause) {
        logTestFinish(context, "aborted");
    }

    @Override
    public void testDisabled(ExtensionContext context, Optional<String> reason) {
        logTestFinish(context, "disabled");
    }

    @Override
    public void testStarted(ExtensionContext context) {
        int testId = testCounter.incrementAndGet();
        logger.info("Test [{} - {}]: {} starting", testId, Thread.currentThread().getName(), context.getDisplayName());
    }

    private void logTestFinish(ExtensionContext context, String status) {
        int testId = testCounter.get();
        logger.info("Test [{} - {}]: {} finished with status: {}", testId, Thread.currentThread().getName(), context.getDisplayName(), status);
    }
}
Step 2: Register the Extension in the Base Test Class
Use the @ExtendWith annotation to apply the extension to the base test class.

java
Skopiuj kod
import org.junit.jupiter.api.extension.ExtendWith;

@ExtendWith(LoggingTestWatcherExtension.class)
public class ITTest {
    // Common setup for all tests can be placed here
}
Step 3: Example Test Classes
Ensure your test classes extend ITTest.

java
Skopiuj kod
import org.junit.jupiter.api.Test;

public class MyTest extends ITTest {

    @Test
    public void testExample() {
        // Your test code here
        System.out.println("Executing testExample");
    }

    @Test
    public void anotherTest() {
        // Your test code here
        System.out.println("Executing anotherTest");
    }
}
Explanation
LoggingTestWatcherExtension:

Implements TestWatcher to log messages before and after each test method.
Uses testStarted to log before a test starts.
Uses testSuccessful, testFailed, testAborted, and testDisabled to log after a test finishes, regardless of the outcome.
Includes a unique identifier and thread name in the log messages to handle parallel execution.
ITTest Class:

Annotated with @ExtendWith(LoggingTestWatcherExtension.class) to apply the extension to all derived test classes.
Test Classes:

Any test class that extends ITTest will automatically log messages before and after each test method execution.
Parallel Execution
To run tests in parallel with JUnit 5, you can configure the junit-platform.properties file or use a build tool configuration.

Example: junit-platform.properties
Create a file named junit-platform.properties in src/test/resources:

properties
Skopiuj kod
junit.jupiter.execution.parallel.enabled = true
junit.jupiter.execution.parallel.mode.default = concurrent
junit.jupiter.execution.parallel.config.strategy = dynamic
This setup ensures that your tests run in parallel while maintaining clear and organized log output, thanks to the inclusion of thread names and unique test identifiers. This way, you can trace the execution of individual tests even when they run concurrently.